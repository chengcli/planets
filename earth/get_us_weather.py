import torch
from netCDF4 import Dataset
import numpy as np

def load_white_sand_weather(filename: str):
    module = torch.jit.load(filename)
    state_dict = module.state_dict()
    data = {k: v.numpy() for k, v in state_dict.items()}
    print(data.keys())
    data["temp"] = data.pop("t")
    data["vel3"] = data.pop("u")
    data["vel2"] = data.pop("v")
    #data["vel1"] = np.zeros_like(data["vel2"])  # no vertical velocity provided
    data["pres"] = data.pop("levels_hpa") * 100.
    data["time"] = data.pop("time_unix")
    data["lat"] = data.pop("latitude")
    data["lon"] = data.pop("longitude")
    print(f"time = {data['time']}")
    print(f"pressure shape = {data['pres'].shape}")

    return data

def interpolate_to_grid(data: dict[str, np.ndarray],
                        x3f: torch.Tensor,
                        x2f: torch.Tensor,
                        x1f: torch.Tensor,
                        nghost: int) -> dict[str, np.ndarray]:
    # center latitude and longitude
    lat_center = 0.5 * (data["lat"][0] + data["lat"][-1])
    lon_center = 0.5 * (data["lon"][0] + data["lon"][-1])

    # calculate longitude span in data (x3)
    lon_span = data["lon"][-1] - data["lon"][0]
    lat_span = data["lat"][-1] - data["lat"][0]

    # convert to distance in meters
    R_earth = 6371000.0  # radius of the Earth in meters
    lon_span_m = (lon_span / 360.0) * 2.0 * np.pi * R_earth * np.cos(np.radians(lat_center))
    lat_span_m = (data["lat"][-1] - data["lat"][0]) / 360.0 * 2.0 * np.pi * R_earth

    # adjust lon_span_m to be centered around zero
    lon_span_m -= 0.5 * (lon_span_m[0] + lon_span_m[-1])
    lat_span_m -= 0.5 * (lat_span_m[0] + lat_span_m[-1])

    # center of computational grid
    x2_center = 0.5 * (x2f[0] + x2f[-1])
    x3_center = 0.5 * (x3f[0] + x3f[-1])

    # match center and re-compute data coordinates
    x3_coord = x3_center + lon_span_m
    x2_coord = x2_center + lat_span_m

    # output grid data
    data_out = {}

    # compute density
    data_out["rho"] = data["pres"] / (287.05 * data["temp"])
    print(data_out["rho"].shape)
    

    print(f"lon_span = {data['lon']} deg, {lon_span_m} m")
    print(f"lat_span = {data['lat']} deg, {lat_span_m} m")

# write weather data to netcdf file
def write_weather_to_netcdf(weather_data, filename: str, resolution: str):
    res = float(resolution[:-1])  # extract numeric part of resolution
    with Dataset(filename, "w", format="NETCDF4") as ncfile:
        # permute data from (time, x3, x2, x1) to (time, x1, x2, x3)
        temp = weather_data["temp"].transpose(0, 3, 2, 1)
        vel2 = weather_data["vel2"].transpose(0, 3, 2, 1)
        vel3 = weather_data["vel3"].transpose(0, 3, 2, 1)
        pres = weather_data["pres"]
        ntime, nx1, nx2, nx3 = temp.shape

        # Define dimensions
        ncfile.createDimension("time", temp.shape[0])
        ncfile.createDimension("x1", temp.shape[1])
        ncfile.createDimension("x2", temp.shape[2])
        ncfile.createDimension("x3", temp.shape[3])

        # coordinate variables
        tvar = ncfile.createVariable("time", "f4", ("time",))
        zvar = ncfile.createVariable("x1", "f4", ("x1",))
        yvar = ncfile.createVariable("x2", "f4", ("x2",))
        xvar = ncfile.createVariable("x3", "f4", ("x3",))

        tvar.units = "seconds since 2025-01-01 00:00:00"
        tvar.axis = "T"
        xvar.units = "meters"
        xvar.axis = "X"
        yvar.units = "meters"
        yvar.axis = "Y"
        zvar.units = "pa"
        zvar.axis = "Z"

        tvar[:] = np.arange(temp.shape[0]).astype("f4")
        zvar[:] = pres.astype("f4")
        yvar[:] = (np.arange(temp.shape[2]) * res).astype("f4")
        xvar[:] = (np.arange(temp.shape[3]) * res).astype("f4")
        
        # Create variables
        temp_var = ncfile.createVariable("temp", "f4", ("time", "x1", "x2", "x3"))
        temp_var.units = "K"
        temp_var.long_name = "Air Temperature"
        temp_var[:] = temp

        #pres_var = ncfile.createVariable("pres", "f4", ("time", "x1", "x2", "x3"))
        #pres_var.units = "Pa"
        #pres_var.long_name = "Air Pressure"
        # broadcast pressure (nx1,) to (ntime, nx1, nx2, nx3)
        #pres_var[:] = pres.reshape(1, nx1, 1, 1) \
        #                  .repeat((ntime, 1, nx2, nx3)) \
        #                  .copy()

        vel2_var = ncfile.createVariable("vel2", "f4", ("time", "x1", "x2", "x3"))
        vel2_var.units = "m/s"
        vel2_var.long_name = "Velocity component in Y-direction"
        vel2_var[:] = vel2

        vel3_var = ncfile.createVariable("vel3", "f4", ("time", "x1", "x2", "x3"))
        vel3_var.units = "m/s"
        vel3_var.long_name = "Velocity component in X-direction"
        vel3_var[:] = vel3

        # Global attributes
        ncfile.description = "4D weather data loaded from TorchScript"
        ncfile.source = "Generated by write_weather_to_netcdf function"

def create_weather_input(fname: str, x1f: torch.Tensor):
    # calcualte density using ideal gas law
    Rgas = 287.05  # J/(kgÂ·K) for dry air
    data["rho"] = data["pres"] / (Rgas * data["temp"])

def test_load_white_sand_weather():
    fname = "era5_by_pressure_modules_2025_Jan_01_AA.pt"
    data = load_white_sand_weather(fname)
    interpolate_to_grid(data,
                        x3f=torch.linspace(-20000.0, 20000.0, 201),
                        x2f=torch.linspace(-20000.0, 20000.0, 201),
                        x1f=torch.tensor(data["pres"]),
                        nghost=3)
    #write_weather_to_netcdf(data, "white_sand_weather_4d.nc", "40m")

if __name__ == "__main__":
    test_load_white_sand_weather()
